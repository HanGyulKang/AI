# 도큐먼트 로더의 종류, 기본 구조, Document 구조

---



## 0. 통합형 Loader 인터페이스 - 기본 정보
* `load()` : 문서 전체 로드
* `load_and_aplit()` : 문서를 `chunk`단위로 로드
* 데이터 반환
    * `page_content` : 문서 내용
    * `metadata` : 메타 정보 - 파일명, 페이지 번호 기타 등등

<br><br>

## 1. Document란?

---

**LangChain의 기본 문서 객체 또는 타입**  
  
**A.** Document 직접 생성
```python
document = Document(
    page_content="Hello, workd!",
    metadata={
        "author": "Kang",
        "source": "C:/document/test.pdf",
        "etc": "blablabla",
        ...
    }
)
```

**B.** 도큐먼트 속성 확인
```python
document.__dict__
```

**C.** 도큐먼트에 나중에 정보 추가
```python
document.metadata["page"] = 1
document.metadata["total_page"] = 36
```

> 추후 임의로 문서 파일을 만들더라도 반드시 **document**타입으로 파일을 감싸줘야  `LangChain`을 활용할 수 있음.

<br><br>

## 2. Document Loader란?

---

[LangChain 에서 사용되는 Document Loader 목록](https://docs.langchain.com/oss/python/integrations/document_loaders)


### - load()
* 문서를 로드하여 반환
* 반환 타입 : `List[Document]`

### - load_and_split()
* 문서를 로드하여 `splitter`를 사용하여 문서를 분할하고 `Chunk`로 반환
* 반환 타입 : `List[Document]`

```python
from langchain_document_loaders import PyPDFLoader
from langchain_text_splitters import RecursiveCharacterTextSplitter

# 문서 분할기 객체 생성
splitter = RecursiveCharacterTextSplitter(chunk_size=100, chunk_overlap=2)

FILE_PATH = "./docs/test.pdf"

def split_loader(filePath):
    # 문서 로드
    loader = PyPDFLoader(filePath)

    # 문서 반환
    splited_docs = loader.load_and_split(text_splitter=splitter)

    # 결과 확인
    print(splited_docs[0])
    print(splited_docs[0].metadata)
    print(splited_docs[0].page_content)

split_loader(FILE_PATH)
```

### - lazy_load()
* 문서의 양이 너무 방대해서 `memory` 부하가 올 것 같을 때 사용
* 한 페이지 씩 읽고 폐기하기 때문에 `memory` 절약에 유용함
```python
for d in loader.lazy_load():
    # 한 페이지 씩 확인, 읽은 후 폐기 됨
    print(d.metadata)
```

### - aload()
* 비동기(Async) 방식의 문서 로드 - `에일로드`라고 읽음